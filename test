import re                  # Expressions régulières pour parser les lignes tcpdump
import csv                 # Lecture / écriture de fichiers CSV
import os                  # Gestion des chemins de fichiers
import tkinter as tk       # Interface graphique Tkinter
from tkinter import filedialog, messagebox
from collections import Counter

import matplotlib
matplotlib.use("Agg")      # Backend sans affichage, génère des PNG sans ouvrir de fenêtre
import matplotlib.pyplot as plt


# ================== PARSING DES LIGNES TCPDUMP ===================

REGEX_LIGNE_IP = re.compile(
    r'^(?P<time>\d{2}:\d{2}:\d{2}\.\d+)\s+IP\s+'
    r'(?P<src>[^ ]+)\s+>\s+(?P<dst>[^:]+):\s+'
    r'Flags\s+\[(?P<flags>[^\]]+)\],\s+'
    r'(?:seq\s+(?P<seq>[0-9:]+),\s+)?'
    r'(?:ack\s+(?P<ack>\d+),\s+)?'
    r'win\s+(?P<win>\d+).*?'
    r'length\s+(?P<length>\d+)'
)
"Décrit le format standard d'une ligne tcpdump contenant un paquet IP/TCP. Extrait les informations essentielles"


def split_ip_port(host_port: str):
    "Prend une chaîne au format 192.168.0.1.443 et la coupe au dernier point pour séparer"
    if '.' not in host_port:
        return host_port, ''
    h, p = host_port.rsplit('.', 1)
    return h, p


def parse_ligne_tcpdump(ligne: str):
    "Applique l'expression regex sur une ligne brute. Si elle correspond au format attendu"
    m = REGEX_LIGNE_IP.match(ligne.strip())
    if not m:
        return None

    time = m.group('time')
    src_raw = m.group('src')
    dst_raw = m.group('dst')
    flags = m.group('flags')
    seq = m.group('seq') or ''
    ack = m.group('ack') or ''
    win = m.group('win')
    length = m.group('length')

    src_ip, src_port = split_ip_port(src_raw)
    dst_ip, dst_port = split_ip_port(dst_raw)

    return {
        'time': time,
        'src_ip': src_ip,
        'src_port': src_port,
        'dst_ip': dst_ip,
        'dst_port': dst_port,
        'flags': flags,
        'seq': seq,
        'ack': ack,
        'win': win,
        'length': length,
    }


def tcpdump_to_csv(fichier_tcpdump: str):
    "Traite un fichier tcpdump ligne par ligne"
    base, _ = os.path.splitext(fichier_tcpdump)
    fichier_csv = base + "_analyse.csv"

    with open(fichier_tcpdump, 'r', encoding='utf-8', errors='ignore') as f_in, \
            open(fichier_csv, 'w', newline='', encoding='utf-8') as f_out:

        champs = ['time', 'src_ip', 'src_port', 'dst_ip', 'dst_port',
                  'flags', 'seq', 'ack', 'win', 'length']
        writer = csv.DictWriter(f_out, fieldnames=champs)
        writer.writeheader()

        for ligne in f_in:
            data = parse_ligne_tcpdump(ligne)
            if data:
                writer.writerow(data)

    return fichier_csv


# ================== ANALYSE & GRAPHIQUES ===================

def charger_csv(fichier_csv):
    "Lit le fichier CSV précédemment généré et retourne une liste complète de tous les paquets sous forme de dictionnaires."
    lignes = []
    with open(fichier_csv, newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            lignes.append(row)
    return lignes


def extraire_flags_principaux(flag_str: str):
    "Pour chaque paquet, identifie son type de drapeau principal et accumule le nombre de paquets de chaque type. Résultat : distribution des types de drapeaux dans la capture."
    flags = set()
    s = (flag_str or '').upper()

    if 'S' in s and 'F' not in s and 'P' not in s and 'U' not in s and 'R' not in s and 'A' not in s:
        flags.add('SYN')
    if 'F' in s and 'P' not in s and 'U' not in s and 'S' not in s:
        flags.add('FIN')
    if 'R' in s:
        flags.add('RST')
    if 'P' in s:
        flags.add('PSH')
    if 'U' in s:
        flags.add('URG')
    if s.strip() in ('', '[]'):
        flags.add('NULL')
    if 'F' in s and 'P' in s and 'U' in s:
        flags.add('XMAS')

    return flags


def compter_par_flags(lignes):
    "Filtre les paquets SYN et les groupe par service destination (adresse IP + port). Identifie quels services reçoivent le plus de SYN → détecte potentiels SYN flood ou DDoS ciblant des services spécifiques."
    c = Counter()
    for row in lignes:
        for f in extraire_flags_principaux(row['flags']):
            c[f] += 1
    return c


def compter_syn_par_service(lignes):
    "Pour chaque adresse IP source, compte le nombre de ports destination différents contactés. Une IP qui touche beaucoup de ports suggère un scan de ports. Résultat : dictionnaire des IP source avec leur nombre de ports distincts."
    c = Counter()
    for row in lignes:
        flags = extraire_flags_principaux(row['flags'])
        if 'SYN' in flags:
            key = f"{row['dst_ip']}:{row['dst_port']}"
            c[key] += 1
    return c


def compter_ports_par_src(lignes):
    "IP sources : compte combien de paquets viennent de chaque source IP destinations : compte combien de paquets arrivent à chaque destination Identifie les IP les plus actives dans les deux sens."
    ports_par_src = Counter()
    for row in lignes:
        ports_par_src[row['src_ip']] += 1
    return ports_par_src


def compter_traffic_par_ip(lignes):
    "Teste si un drapeau contient SYN mais pas ACK. Caractérise une connexion nouvelle ou une attaque SYN flood (nombreux SYN sans ACK)."
    src_count = Counter()
    dst_count = Counter()
    for row in lignes:
        src_count[row['src_ip']] += 1
        dst_count[row['dst_ip']] += 1
    return src_count, dst_count


def est_syn_seul(flags: str) -> bool:
    "Teste si un drapeau contient SYN mais pas ACK. Caractérise une connexion nouvelle ou une attaque SYN flood (nombreux SYN sans ACK)."
    f = (flags or '').upper()
    return 'S' in f and 'A' not in f


def top5_src_ip_syn(lignes):
    "Identifie les 5 adresses IP source envoyant le plus de paquets SYN seuls. Cibles potentielles pour une enquête de sécurité."
    compteur = Counter()
    for row in lignes:
        if est_syn_seul(row['flags']):
            compteur[row['src_ip']] += 1
    return compteur.most_common(5)


def compter_paquets_par_temps(lignes):
    # Agrégation par seconde : "HH:MM:SS.mmm" -> "HH:MM:SS"
    compteur = Counter()
    for row in lignes:
        t = row['time'].split('.')[0]
        compteur[t] += 1
    temps_tries = sorted(compteur.items(), key=lambda x: x[0])
    x = [t for t, _ in temps_tries]
    y = [n for _, n in temps_tries]
    return x, y


def plot_bar(counter_dict, titre, xlabel, ylabel, output_path, max_items=10):
    "Fonction générique pour créer des diagrammes en barres"
    if not counter_dict:
        return
    items = sorted(counter_dict.items(), key=lambda x: x[1], reverse=True)[:max_items]
    labels = [k for k, _ in items]
    values = [v for _, v in items]

    plt.figure(figsize=(10, 5))
    plt.bar(labels, values)
    plt.xticks(rotation=45, ha='right', fontsize=8)
    plt.title(titre)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()


def plot_pie(counter_dict, titre, output_path, min_pct=1.0):
    "Fonction générique pour créer des diagrammes circulaires "
    if not counter_dict:
        return

    labels = []
    sizes = []
    total = sum(counter_dict.values())

    for k, v in counter_dict.items():
        pct = v * 100.0 / total
        if pct >= min_pct:
            labels.append(k)
            sizes.append(v)

    if not sizes:
        return

    plt.figure(figsize=(6, 6))
    plt.pie(
        sizes,
        labels=labels,
        autopct='%1.1f%%',
        startangle=90
    )
    plt.title(titre)
    plt.axis('equal')
    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()


def plot_line(x, y, titre, xlabel, ylabel, output_path):
    "Fonction générique pour créer des courbe "
    if not x or not y:
        return
    plt.figure(figsize=(10, 5))
    plt.plot(x, y, marker='o')
    plt.xticks(rotation=45, ha='right', fontsize=8)
    plt.title(titre)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()


def generer_graphiques_et_rapports(fichier_csv):
    lignes = charger_csv(fichier_csv)
    if not lignes:
        return None, None

    dossier = os.path.dirname(fichier_csv)
    base = os.path.splitext(os.path.basename(fichier_csv))[0]

    # 1) Répartition des flags (barres)
    flags_count = compter_par_flags(lignes)
    img_flags = os.path.join(dossier, base + "_flags.png")
    plot_bar(
        flags_count,
        "Répartition des principaux flags TCP",
        "Flags",
        "Nombre de paquets",
        img_flags
    )

    # 1bis) Répartition des flags (camembert)
    img_flags_pie = os.path.join(dossier, base + "_flags_pie.png")
    plot_pie(
        flags_count,
        "Répartition des principaux flags TCP (camembert)",
        img_flags_pie
    )

    # 2) TOP services (dst_ip:dst_port) avec beaucoup de SYN
    syn_par_service = compter_syn_par_service(lignes)
    img_syn = os.path.join(dossier, base + "_syn_services.png")
    plot_bar(
        syn_par_service,
        "Top services par nombre de SYN (potentiel SYN flood / DDoS)",
        "dst_ip:dst_port",
        "Nombre de SYN",
        img_syn
    )

    # 3) TOP sources par nombre total de ports touchés (port scan)
    ports_par_src = compter_ports_par_src(lignes)
    img_pscan = os.path.join(dossier, base + "_portscan.png")
    plot_bar(
        ports_par_src,
        "Top IP source par nombre total de ports ciblés (port scan)",
        "src_ip",
        "Nombre total de ports (avec répétition)",
        img_pscan
    )

    # IP la plus « large » en ports
    ip_plus_ports = None
    nb_ports_max = 0
    for ip, nb_ports in ports_par_src.items():
        if nb_ports > nb_ports_max:
            nb_ports_max = nb_ports
            ip_plus_ports = ip

    img_ports_ip = None
    if ip_plus_ports:
        ports_count = Counter()
        for row in lignes:
            if row['src_ip'] == ip_plus_ports:
                ports_count[row['dst_port']] += 1

        if ports_count:
            img_ports_ip = os.path.join(dossier, base + f"_{ip_plus_ports}_ports_freq.png")
            plot_bar(
                ports_count,
                f"Ports touchés par {ip_plus_ports} (nombre de fois)",
                "Port destination",
                "Nombre de paquets",
                img_ports_ip,
                max_items=len(ports_count)
            )

    # 4) TOP IP source / destination par volume de paquets
    src_count, dst_count = compter_traffic_par_ip(lignes)
    img_src = os.path.join(dossier, base + "_top_src.png")
    plot_bar(
        src_count,
        "Top IP source par nombre de paquets",
        "src_ip",
        "Nombre de paquets",
        img_src
    )

    img_dst = os.path.join(dossier, base + "_top_dst.png")
    plot_bar(
        dst_count,
        "Top IP destination par nombre de paquets",
        "dst_ip",
        "Nombre de paquets",
        img_dst
    )

    # 5) GRAPHIQUE TOP 5 SRC_IP SYN SEULS
    top5_syn_list = top5_src_ip_syn(lignes)
    img_top5_syn = None
    if top5_syn_list:
        d_top5 = {ip: nb for ip, nb in top5_syn_list}
        img_top5_syn = os.path.join(dossier, base + "_top5_syn_src.png")
        plot_bar(
            d_top5,
            "Top 5 IP source par nombre de SYN (SYN seuls)",
            "src_ip",
            "Nombre de SYN",
            img_top5_syn
        )

    # 6) Courbe temps / nombre de paquets (agrégé à la seconde)
    x_time, y_count = compter_paquets_par_temps(lignes)
    img_time = os.path.join(dossier, base + "_time_series.png")
    plot_line(
        x_time,
        y_count,
        "Évolution du nombre de paquets dans le temps",
        "Temps (HH:MM:SS)",
        "Nombre de paquets",
        img_time
    )

    # ===== Génération HTML avec Bootstrap + Bootswatch (Darkly) =====
    fichier_html = os.path.join(dossier, base + "_rapport.html")
    with open(fichier_html, "w", encoding="utf-8") as f:
        f.write("<!DOCTYPE html>\n<html lang='fr'>\n<head>\n")
        f.write("<meta charset='UTF-8'>\n")
        f.write(f"<title>Rapport d'analyse : {base}</title>\n")
        f.write(
            "<link rel='stylesheet' "
            "href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css'>\n"
        )
        f.write(
            "<link rel='stylesheet' "
            "href='https://cdn.jsdelivr.net/npm/bootswatch@5.3.3/dist/darkly/bootstrap.min.css'>\n"
        )
        f.write("</head>\n<body class='container my-4'>\n")
        f.write(f"<h1 class='mb-4'>Rapport d'analyse réseau : {base}</h1>\n")
        f.write(
            "<p class='lead'>Ce rapport regroupe des graphiques pour aider à visualiser "
            "de potentielles attaques (SYN flood / DDoS, port scan, scans basés sur les flags TCP).</p>\n"
        )

        if ip_plus_ports:
            f.write(
                "<div class='alert alert-warning'>"
                f"IP avec le plus grand nombre de ports touchés (scan possible) : "
                f"<strong>{ip_plus_ports}</strong> ({nb_ports_max} ports au total)"
                "</div>\n"
            )

        # 1) Répartition des flags TCP
        f.write("<div class='card mb-4'>\n")
        f.write("  <div class='card-header'>Répartition des flags TCP</div>\n")
        f.write("  <div class='card-body text-center'>\n")
        f.write(f"    <img src='{os.path.basename(img_flags)}' "
                f"alt='Répartition des flags TCP' class='img-fluid' />\n")
        f.write("  </div>\n</div>\n")

        # 2) Répartition des flags TCP (camembert)
        f.write("<div class='card mb-4'>\n")
        f.write("  <div class='card-header'>Répartition des flags TCP (camembert)</div>\n")
        f.write("  <div class='card-body text-center'>\n")
        f.write(f"    <img src='{os.path.basename(img_flags_pie)}' "
                f"alt='Répartition des flags TCP (camembert)' class='img-fluid' />\n")
        f.write("  </div>\n</div>\n")

        # 3) Top IP source
        f.write("<div class='card mb-4'>\n")
        f.write("  <div class='card-header'>Top IP source</div>\n")
        f.write("  <div class='card-body text-center'>\n")
        f.write(f"    <img src='{os.path.basename(img_src)}' "
                f"alt='Top IP source' class='img-fluid' />\n")
        f.write("  </div>\n</div>\n")

        # 4) Top IP destination
        f.write("<div class='card mb-4'>\n")
        f.write("  <div class='card-header'>Top IP destination</div>\n")
        f.write("  <div class='card-body text-center'>\n")
        f.write(f"    <img src='{os.path.basename(img_dst)}' "
                f"alt='Top IP destination' class='img-fluid' />\n")
        f.write("  </div>\n</div>\n")

        # 5) Services ciblés (SYN)
        f.write("<div class='card mb-4'>\n")
        f.write("  <div class='card-header'>Services ciblés (SYN)</div>\n")
        f.write("  <div class='card-body text-center'>\n")
        f.write(f"    <img src='{os.path.basename(img_syn)}' "
                f"alt='Services ciblés (SYN)' class='img-fluid' />\n")
        f.write("  </div>\n</div>\n")

        # 6) Top 5 IP source (SYN seuls)
        if img_top5_syn:
            f.write("<div class='card mb-4'>\n")
            f.write("  <div class='card-header'>Top 5 IP source (SYN seuls)</div>\n")
            f.write("  <div class='card-body text-center'>\n")
            f.write(f"    <img src='{os.path.basename(img_top5_syn)}' "
                    f"alt='Top 5 IP source (SYN seuls)' class='img-fluid' />\n")
            f.write("  </div>\n</div>\n")

        # 7) Sources possibles de port scan
        f.write("<div class='card mb-4'>\n")
        f.write("  <div class='card-header'>Sources possibles de port scan</div>\n")
        f.write("  <div class='card-body text-center'>\n")
        f.write(f"    <img src='{os.path.basename(img_pscan)}' "
                f"alt='Sources possibles de port scan' class='img-fluid' />\n")
        f.write("  </div>\n</div>\n")

        # 8) Ports scannés par l'IP la plus active
        if img_ports_ip:
            f.write("<div class='card mb-4'>\n")
            f.write(f"  <div class='card-header'>Ports scannés par {ip_plus_ports}</div>\n")
            f.write("  <div class='card-body text-center'>\n")
            f.write(f"    <img src='{os.path.basename(img_ports_ip)}' "
                    f"alt='Ports scannés par {ip_plus_ports}' class='img-fluid' />\n")
            f.write("  </div>\n</div>\n")

        # 9) Nombre de paquets dans le temps
        f.write("<div class='card mb-4'>\n")
        f.write("  <div class='card-header'>Nombre de paquets dans le temps</div>\n")
        f.write("  <div class='card-body text-center'>\n")
        f.write(f"    <img src='{os.path.basename(img_time)}' "
                f"alt='Nombre de paquets dans le temps' class='img-fluid' />\n")
        f.write("  </div>\n</div>\n")

        f.write("</body>\n</html>\n")

    # ===== Génération Markdown (texte uniquement) =====
    fichier_md = os.path.join(dossier, base + "_rapport.md")
    with open(fichier_md, "w", encoding="utf-8") as f:
        f.write(f"# Rapport d'analyse réseau : {base}\n\n")
        f.write(
            "Ce rapport regroupe des informations utiles pour détecter "
            "de potentielles attaques (SYN flood / DDoS, port scan, "
            "scans basés sur les flags TCP).\n\n"
        )

        if ip_plus_ports:
            f.write("## IP avec le plus grand nombre de ports touchés\n\n")
            f.write(f"- IP suspecte (port scan possible) : **{ip_plus_ports}**\n")
            f.write(f"- Nombre total de ports touchés (paquets) : **{nb_ports_max}**\n\n")

        f.write("## Répartition des principaux flags TCP\n\n")
        if flags_count:
            f.write("| Flag | Nombre de paquets |\n")
            f.write("|------|-------------------|\n")
            for flag, nb in flags_count.most_common():
                f.write(f"| {flag} | {nb} |\n")
            f.write("\n")
        else:
            f.write("Aucun paquet trouvé pour les flags TCP.\n\n")

        f.write("## Top services par nombre de SYN (potentiel SYN flood / DDoS)\n\n")
        if syn_par_service:
            f.write("| Service (dst_ip:port) | Nombre de SYN |\n")
            f.write("|------------------------|---------------|\n")
            for service, nb in syn_par_service.most_common(10):
                f.write(f"| {service} | {nb} |\n")
            f.write("\n")
        else:
            f.write("Aucun SYN détecté vers des services spécifiques.\n\n")

        f.write("## Top IP source par nombre total de ports touchés (port scan)\n\n")
        if ports_par_src:
            f.write("| IP source | Nombre total de ports (paquets) |\n")
            f.write("|-----------|----------------------------------|\n")
            for ip, nb in sorted(ports_par_src.items(), key=lambda x: x[1], reverse=True)[:10]:
                f.write(f"| {ip} | {nb} |\n")
            f.write("\n")
        else:
            f.write("Aucune activité de scan de ports détectée.\n\n")

        f.write("## Top IP source par nombre de paquets\n\n")
        if src_count:
            f.write("| IP source | Nombre de paquets |\n")
            f.write("|-----------|-------------------|\n")
            for ip, nb in src_count.most_common(10):
                f.write(f"| {ip} | {nb} |\n")
            f.write("\n")
        else:
            f.write("Aucun paquet source détecté.\n\n")

        f.write("## Top IP destination par nombre de paquets\n\n")
        if dst_count:
            f.write("| IP destination | Nombre de paquets |\n")
            f.write("|----------------|-------------------|\n")
            for ip, nb in dst_count.most_common(10):
                f.write(f"| {ip} | {nb} |\n")
            f.write("\n")
        else:
            f.write("Aucun paquet destination détecté.\n\n")

        f.write("## Top 5 IP source par nombre de SYN (SYN seuls)\n\n")
        if top5_syn_list:
            f.write("| IP source | Nombre de SYN |\n")
            f.write("|-----------|---------------|\n")
            for ip, nb in top5_syn_list:
                f.write(f"| {ip} | {nb} |\n")
            f.write("\n")
            f.write(
                f"IP la plus active en SYN seuls : **{top5_syn_list[0][0]}** "
                f"avec **{top5_syn_list[0][1]}** paquets.\n\n"
            )
        else:
            f.write("Aucune IP envoyant des SYN seuls de manière significative.\n\n")

        f.write("## Évolution du nombre de paquets dans le temps\n\n")
        f.write(
            "Un graphique en courbe est disponible dans le rapport HTML pour visualiser "
            "le nombre de paquets par seconde.\n\n"
        )

    return fichier_html, fichier_md


# ================== INTERFACE TKINTER ===================

def choisir_fichier():
    chemin_fichier = filedialog.askopenfilename(
        title="Sélectionner un fichier tcpdump",
        filetypes=[("Fichiers texte", "*.txt *.log"), ("Tous les fichiers", "*.*")]
    )

    if chemin_fichier:
        label_chemin.config(text=f"Fichier sélectionné : {chemin_fichier}")
        try:
            csv_genere = tcpdump_to_csv(chemin_fichier)
            rapport_html, rapport_md = generer_graphiques_et_rapports(csv_genere)

            msg = f"CSV généré : {csv_genere}"

            if rapport_html:
                msg += f"\nRapport HTML : {rapport_html}"
            else:
                msg += "\nAucun rapport HTML généré (CSV vide ?)"

            if rapport_md:
                msg += f"\nRapport Markdown : {rapport_md}"
            else:
                msg += "\nAucun rapport Markdown généré (CSV vide ?)"

            messagebox.showinfo("Terminé", msg)

        except Exception as e:
            messagebox.showerror("Erreur", f"Une erreur est survenue : {e}")
    else:
        label_chemin.config(text="Aucun fichier sélectionné")


def quitter():
    fenetre.destroy()


fenetre = tk.Tk()
fenetre.title("tcpdump ---> CSV + Rapport")
fenetre.geometry("450x260")

btn_choisir_fichier = tk.Button(fenetre, text="Choisir un fichier", command=choisir_fichier)
btn_choisir_fichier.pack(pady=20)

label_chemin = tk.Label(fenetre, text="Aucun fichier sélectionné", wraplength=420)
label_chemin.pack(pady=20)

btn_quitter = tk.Button(fenetre, text="Quitter", command=quitter)
btn_quitter.pack(pady=20)

fenetre.mainloop()
