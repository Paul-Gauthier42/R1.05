import re
import csv
import os
import tkinter as tk
from tkinter import filedialog, messagebox
from collections import Counter, defaultdict

import matplotlib
matplotlib.use("Agg")  
import matplotlib.pyplot as plt


# ================== annalyse des données ===================

REGEX_LIGNE_IP = re.compile(
    r'^(?P<time>\d{2}:\d{2}:\d{2}\.\d+)\s+IP\s+'
    r'(?P<src>[^ ]+)\s+>\s+(?P<dst>[^:]+):\s+'
    r'Flags\s+\[(?P<flags>[^\]]+)\],\s+'
    r'(?:seq\s+(?P<seq>[0-9:]+),\s+)?'
    r'(?:ack\s+(?P<ack>\d+),\s+)?'
    r'win\s+(?P<win>\d+).*?'
    r'length\s+(?P<length>\d+)'
)
"Décrit le format standard d'une ligne tcpdump contenant un paquet IP/TCP. Extrait les informations essentielles"

def split_ip_port(host_port: str):
    "Prend une chaîne au format 192.168.0.1.443 et la coupe au dernier point pour séparer"
    if '.' not in host_port:
        return host_port, ''
    h, p = host_port.rsplit('.', 1)
    return h, p


def parse_ligne_tcpdump(ligne: str):
    "Applique l'expression regex sur une ligne brute. Si elle correspond au format attendu"
    m = REGEX_LIGNE_IP.match(ligne.strip())
    if not m:
        return None

    time = m.group('time')
    src_raw = m.group('src')
    dst_raw = m.group('dst')
    flags = m.group('flags')
    seq = m.group('seq') or ''
    ack = m.group('ack') or ''
    win = m.group('win')
    length = m.group('length')

    src_ip, src_port = split_ip_port(src_raw)
    dst_ip, dst_port = split_ip_port(dst_raw)

    return {
        'time': time,
        'src_ip': src_ip,
        'src_port': src_port,
        'dst_ip': dst_ip,
        'dst_port': dst_port,
        'flags': flags,
        'seq': seq,
        'ack': ack,
        'win': win,
        'length': length,
    }


def tcpdump_to_csv(fichier_tcpdump: str):
    "Traite un fichier tcpdump ligne par ligne"
    base, _ = os.path.splitext(fichier_tcpdump)
    fichier_csv = base + "_analyse.csv"

    with open(fichier_tcpdump, 'r', encoding='utf-8', errors='ignore') as f_in, \
         open(fichier_csv, 'w', newline='', encoding='utf-8') as f_out:

        champs = ['time','src_ip','src_port','dst_ip','dst_port','flags','seq','ack','win','length']
        writer = csv.DictWriter(f_out, fieldnames=champs)
        writer.writeheader()

        for ligne in f_in:
            data = parse_ligne_tcpdump(ligne)
            if data:
                writer.writerow(data)

    return fichier_csv


# ================== ANALYSE & GRAPHIQUES ===================

def charger_csv(fichier_csv):
    "Lit le fichier CSV précédemment généré et retourne une liste complète de tous les paquets sous forme de dictionnaires."
    lignes = []
    with open(fichier_csv, newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            lignes.append(row)
    return lignes


def extraire_flags_principaux(flag_str: str):
    "Pour chaque paquet, identifie son type de drapeau principal et accumule le nombre de paquets de chaque type. Résultat : distribution des types de drapeaux dans la capture."
    flags = set()
    s = flag_str.upper()

    if 'S' in s and 'F' not in s and 'P' not in s and 'U' not in s and 'R' not in s and 'A' not in s:
        flags.add('SYN')
    if 'F' in s and 'P' not in s and 'U' not in s and 'S' not in s:
        flags.add('FIN')
    if 'R' in s:
        flags.add('RST')
    if 'P' in s:
        flags.add('PSH')
    if 'U' in s:
        flags.add('URG')
    if s.strip() in ('', '[]'):
        flags.add('NULL')
    if 'F' in s and 'P' in s and 'U' in s:
        flags.add('XMAS')

    return flags


def compter_par_flags(lignes):
    "Filtre les paquets SYN et les groupe par service destination (adresse IP + port). Identifie quels services reçoivent le plus de SYN → détecte potentiels SYN flood ou DDoS ciblant des services spécifiques."
    c = Counter()
    for row in lignes:
        for f in extraire_flags_principaux(row['flags']):
            c[f] += 1
    return c


def compter_syn_par_service(lignes):
    "Pour chaque adresse IP source, compte le nombre de ports destination différents contactés. Une IP qui touche beaucoup de ports suggère un scan de ports. Résultat : dictionnaire des IP source avec leur nombre de ports distincts."
    c = Counter()
    for row in lignes:
        flags = extraire_flags_principaux(row['flags'])
        if 'SYN' in flags:
            key = f"{row['dst_ip']}:{row['dst_port']}"
            c[key] += 1
    return c


def compter_ports_par_src(lignes):
    " IP sources : compte combien de paquets viennent de chaque source IP destinations : compte combien de paquets arrivent à chaque destination Identifie les IP les plus actives dans les deux sens."
    ports_par_src = defaultdict(set)
    for row in lignes:
        ports_par_src[row['src_ip']].add(row['dst_port'])
    return {src: len(ports) for src, ports in ports_par_src.items()}



def compter_traffic_par_ip(lignes):
    "Teste si un drapeau contient SYN mais pas ACK. Caractérise une connexion nouvelle ou une attaque SYN flood (nombreux SYN sans ACK)."
    src_count = Counter()
    dst_count = Counter()
    for row in lignes:
        src_count[row['src_ip']] += 1
        dst_count[row['dst_ip']] += 1
    return src_count, dst_count



def est_syn_seul(flags: str) -> bool:
    "Teste si un drapeau contient SYN mais pas ACK. Caractérise une connexion nouvelle ou une attaque SYN flood (nombreux SYN sans ACK)."
    f = flags.upper()
    return 'S' in f and 'A' not in f


def top5_src_ip_syn(lignes):
    "Identifie les 5 adresses IP source envoyant le plus de paquets SYN seuls. Cibles potentielles pour une enquête de sécurité."
    compteur = Counter()
    for row in lignes:
        if est_syn_seul(row['flags']):
            compteur[row['src_ip']] += 1
    return compteur.most_common(5)


def plot_bar(counter_dict, titre, xlabel, ylabel, output_path, max_items=10):
    "Fonction générique pour créer des diagrammes en barres"
    if not counter_dict:
        return
    items = sorted(counter_dict.items(), key=lambda x: x[1], reverse=True)[:max_items]
    labels = [k for k, _ in items]
    values = [v for _, v in items]

    plt.figure(figsize=(10, 5))
    plt.bar(labels, values)
    plt.xticks(rotation=45, ha='right', fontsize=8)
    plt.title(titre)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()


def plot_pie(counter_dict, titre, output_path, min_pct=1.0):
    "Fonction générique pour créer des diagrammes circulaires "
    if not counter_dict:
        return

    labels = []
    sizes = []
    total = sum(counter_dict.values())

    for k, v in counter_dict.items():
        pct = v * 100.0 / total
        if pct >= min_pct:
            labels.append(k)
            sizes.append(v)

    if not sizes:
        return

    plt.figure(figsize=(6, 6))
    plt.pie(
        sizes,
        labels=labels,
        autopct='%1.1f%%',
        startangle=90
    )
    plt.title(titre)
    plt.axis('equal')
    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()


def generer_graphiques_et_html(fichier_csv):
    lignes = charger_csv(fichier_csv)
    if not lignes:
        return None

    dossier = os.path.dirname(fichier_csv)
    base = os.path.splitext(os.path.basename(fichier_csv))[0]

    images = []

    # 1) Répartition des flags (barres)
    flags_count = compter_par_flags(lignes)
    img_flags = os.path.join(dossier, base + "_flags.png")
    plot_bar(flags_count,
             "Répartition des principaux flags TCP",
             "Flags",
             "Nombre de paquets",
             img_flags)
    images.append(("Répartition des flags TCP", os.path.basename(img_flags)))

    # 1bis) Répartition des flags (camembert)
    img_flags_pie = os.path.join(dossier, base + "_flags_pie.png")
    plot_pie(flags_count,
             "Répartition des principaux flags TCP (camembert)",
             img_flags_pie)
    images.append(("Répartition des flags TCP (camembert)", os.path.basename(img_flags_pie)))

    # 2) TOP services (dst_ip:dst_port) avec beaucoup de SYN
    syn_par_service = compter_syn_par_service(lignes)
    img_syn = os.path.join(dossier, base + "_syn_services.png")
    plot_bar(syn_par_service,
             "Top services par nombre de SYN (potentiel SYN flood / DDoS)",
             "dst_ip:dst_port",
             "Nombre de SYN",
             img_syn)
    images.append(("Services ciblés (SYN)", os.path.basename(img_syn)))

    # 3) TOP sources par nombre de ports distincts (port scan)
    ports_par_src = compter_ports_par_src(lignes)
    img_pscan = os.path.join(dossier, base + "_portscan.png")
    plot_bar(ports_par_src,
             "Top IP source par nombre de ports touchés (port scan)",
             "src_ip",
             "Nombre de ports distincts",
             img_pscan)
    images.append(("Sources possibles de port scan", os.path.basename(img_pscan)))

    ### IP la plus « large » en ports → détail par port
    ip_plus_ports = None
    nb_ports_max = 0
    for ip, nb_ports in ports_par_src.items():
        if nb_ports > nb_ports_max:
            nb_ports_max = nb_ports
            ip_plus_ports = ip

    if ip_plus_ports:
        # compter combien de fois chaque port a été touché par cette IP
        ports_count = Counter()
        for row in lignes:
            if row['src_ip'] == ip_plus_ports:
                ports_count[row['dst_port']] += 1

        if ports_count:
            img_ports_ip = os.path.join(dossier, base + f"_{ip_plus_ports}_ports_freq.png")
            plot_bar(
                ports_count,
                f"Ports touchés par {ip_plus_ports} (nombre de fois)",
                "Port destination",
                "Nombre de paquets",
                img_ports_ip,
                max_items=len(ports_count)  # tous les ports de cette IP
            )
            images.append((f"Ports scannés par {ip_plus_ports}", os.path.basename(img_ports_ip)))

    # 4) TOP IP source / destination par volume de paquets
    src_count, dst_count = compter_traffic_par_ip(lignes)
    img_src = os.path.join(dossier, base + "_top_src.png")
    plot_bar(src_count,
             "Top IP source par nombre de paquets",
             "src_ip",
             "Nombre de paquets",
             img_src)
    images.append(("Top IP source", os.path.basename(img_src)))

    img_dst = os.path.join(dossier, base + "_top_dst.png")
    plot_bar(dst_count,
             "Top IP destination par nombre de paquets",
             "dst_ip",
             "Nombre de paquets",
             img_dst)
    images.append(("Top IP destination", os.path.basename(img_dst)))

    # 5) GRAPHIQUE TOP 5 SRC_IP SYN SEULS
    top5_syn = top5_src_ip_syn(lignes)
    premier_ip_syn = None
    if top5_syn:
        d_top5 = {ip: nb for ip, nb in top5_syn}
        img_top5_syn = os.path.join(dossier, base + "_top5_syn_src.png")
        plot_bar(d_top5,
                 "Top 5 IP source par nombre de SYN (SYN seuls)",
                 "src_ip",
                 "Nombre de SYN",
                 img_top5_syn)
        images.append(("Top 5 IP source (SYN seuls)", os.path.basename(img_top5_syn)))
        premier_ip_syn = top5_syn[0][0]

    # 6) Graphes dédiés à la première IP SYN (déjà fait précédemment, si tu les gardes)

    # Génération de la page HTML
    fichier_html = os.path.join(dossier, base + "_rapport.html")
    with open(fichier_html, "w", encoding="utf-8") as f:
        f.write("<!DOCTYPE html>\n<html lang='fr'>\n<head>\n")
        f.write("<meta charset='UTF-8'>\n")
        f.write(f"<title>Rapport d'analyse : {base}</title>\n")
        f.write("<style>body{font-family:Arial, sans-serif;} img{max-width:100%;}</style>\n")
        f.write("</head>\n<body>\n")
        f.write(f"<h1>Rapport d'analyse réseau : {base}</h1>\n")
        f.write("<p>Ce rapport regroupe des graphiques pour aider à visualiser de potentielles attaques (SYN flood / DDoS, port scan, scans basés sur les flags TCP).</p>\n")

        if ip_plus_ports:
            f.write(f"<p>IP avec le plus grand nombre de ports touchés (scan possible) : <b>{ip_plus_ports}</b></p>\n")

        for titre, img_name in images:
            f.write(f"<h2>{titre}</h2>\n")
            f.write(f"<img src='{img_name}' alt='{titre}' />\n")

        f.write("</body>\n</html>\n")

    return fichier_html


# ================== INTERFACE TKINTER ===================

def choisir_fichier():
    chemin_fichier = filedialog.askopenfilename(
        title="Sélectionner un fichier tcpdump",
        filetypes=[("Fichiers texte", "*.txt *.log"), ("Tous les fichiers", "*.*")]
    )

    if chemin_fichier:
        label_chemin.config(text=f"Fichier sélectionné : {chemin_fichier}")
        try:
            csv_genere = tcpdump_to_csv(chemin_fichier)
            rapport_html = generer_graphiques_et_html(csv_genere)
            msg = f"CSV généré : {csv_genere}"
            if rapport_html:
                msg += f"\nRapport HTML : {rapport_html}"
            messagebox.showinfo("Terminé", msg)
        except Exception as e:
            messagebox.showerror("Erreur", f"Une erreur est survenue : {e}")
    else:
        label_chemin.config(text="Aucun fichier sélectionné")


def quitter():
    fenetre.destroy()


fenetre = tk.Tk()
fenetre.title("tcpdump ---> CSV + Rapport")
fenetre.geometry("450x260")

btn_choisir_fichier = tk.Button(fenetre, text="Choisir un fichier", command=choisir_fichier)
btn_choisir_fichier.pack(pady=20)

label_chemin = tk.Label(fenetre, text="Aucun fichier sélectionné", wraplength=420)
label_chemin.pack(pady=20)

btn_quitter = tk.Button(fenetre, text="Quitter", command=quitter)
btn_quitter.pack(pady=20)

fenetre.mainloop()
